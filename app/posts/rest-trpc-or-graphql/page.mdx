export const metadata = {
	title:
		"REST API, tRPC, or GraphQL? What would you choose for your new mobile app startup?",
	description:
		"Choosing between REST, tRPC and GraphQL for mobile app backends ‚Äî pros and cons from a developer's perspective.",
	openGraph: { type: "article", images: "/vazco.svg" },
	twitter: { card: "summary_large_image" },
};

# REST API, tRPC, or GraphQL? What would you choose for your new mobile app startup?

Recently, I decided to bring one of my countless startup ideas to life ü§ì, and I got stuck on choosing a communication protocol between the mobile app and the backend. Unusually for me, I chose the path of least resistance and decided not to overthink architecture and so on ‚Äî just to start building the product. Knowing that it likely won‚Äôt ever see the light of day, I didn‚Äôt worry much about optimizations, architecture, folder structures, or developer experience. I just wanted to start coding the product in a way that was reasonably convenient for me.

So, in short ‚Äî this was supposed to be a mobile app with a separate backend. I don‚Äôt like building serverless apps because they limit me a bit. Sometimes it‚Äôs hard to implement file size/type validators, notification logic, cron jobs, etc. I prefer building a separate backend from the start so that the project is frontend-independent. That way I can change the UI anytime without having to move or rewrite a lot of business logic. _But that‚Äôs not the point of this story._

## REST API - the old way

As usual, I decided to use a REST API. I wrote some standard endpoints using the [Hono framework](https://hono.dev/). I could‚Äôve used [Express](https://expressjs.com/), but since the developer behind Express also created Hono, I figured there was some reasoning behind it. Everything was fine, the backend worked, so I moved on to the mobile app. That‚Äôs when problems started appearing. I used [`react-query`](https://tanstack.com/query/latest) as the client to communicate with the backend. Pretty quickly, I realized I was missing generated types. ‚ÄúWriting them manually is really dumb. I don‚Äôt see the point in duplicating types when I could just generate them using some tool‚Äù - I thought.

### OpenAPI - "workaround" for type safety

That‚Äôs why I decided to integrate my backend with [OpenAPI](https://www.openapis.org/). Luckily, Hono has integration with [`@hono/zod-openapi`](https://hono.dev/examples/zod-openapi), which allows defining endpoints strictly using Zod schemas.

I refactored the backend a bit and got to work on the mobile app. On the frontend, I used the [`orval`](https://orval.dev/) library, which parsed the OpenAPI schema and generated types and typed hooks for `react-query`. That was better, I thought. But the types had weird names like `GetUsersResponseOpenApi200` or something like that. I get it ‚Äî the backend can return different statuses and errors ‚Äî but for a startup I‚Äôm building just to test an idea, that was overkill. I didn‚Äôt want to handle every error or add custom statuses to Zod schemas in `@hono/zod-openapi`, and then deal with a mess of types generated by `orval`. I didn‚Äôt like it ‚Äî it looked messy. I still wanted to simplify the DX so I could focus more on business logic than type definitions and schema configurations.

### OpenAPI Swagger UI

But, it worth mentioning that the integration with Hono and [Swagger UI](https://hono.dev/examples/swagger-ui) is pretty cool (via `@hono/swagger-ui`). I could easily test the backend endpoints, see the request/response schemas, and even try out the endpoints directly from the Swagger UI. That was a nice touch. But as a developer, I focus more on the code than the UI. I don‚Äôt need a fancy UI to see what my endpoints returns. Types should speak for themselves. So, while the Swagger UI was nice, it didn‚Äôt really solve my problem.

## tRPC - hyped "workaround" for REST API

At that point, I decided to try [tRPC](https://trpc.io/), which would give me powerful typing out of the box without complex configuration or auto-generating types.

### Monorepo - the only place where tRPC makes sense

It‚Äôs worth noting that I‚Äôm working in a monorepo, so I can easily import the main app router type on the frontend. In my setup, though, development became easier. I had to refactor the backend a bit again, but now I know for sure: REST API is dead for me üíÄ _(*in terms of developing mobile apps)_. Since tRPC communicates over HTTP, it‚Äôs essentially a typed REST API. If you write a backend in tRPC and later want to change the frontend to another language (not TypeScript), you can still make requests to the backend ‚Äî you just won‚Äôt have type safety. But in that case, you‚Äôd probably have to define an OpenAPI spec and tweak the backend a bit anyway. I mostly use TypeScript for everything, so I‚Äôm not worried about it.

If you‚Äôre using separate repos for frontend and backend, you could theoretically still do this ‚Äî you‚Äôd just need to locally link the backend package or set up automatic publishing. But yeah, it‚Äôs a bit of extra work and arguably not easier than using OpenAPI.

Additionally, since I‚Äôm working in a monorepo, it made sense to create a shared package with Zod schemas to avoid duplicating code. Very convenient ‚Äî I recommend doing the same.

### Enums - missing piece - the downside

However, one small issue remains. I haven‚Äôt found a way to share enums between the frontend and backend. I use [Prisma](https://www.prisma.io/), which generates types and enums. But the problem is I can‚Äôt use them on the frontend without adding Prisma as a dependency ‚Äî which I don‚Äôt actually use there. As a workaround, I just duplicated the enums into a shared package and used them on the frontend.

Another option would be to create a separate shared package that only exports the generated enums. But that‚Äôs a lot of manual, one-time work and a bit of overkill. At least in Prisma version 6.7.0, it now generates separate modules (enums, types, etc.), which might simplify this setup later. But that‚Äôs for another time (never).

## GraphQL - goat üêê

Did I stick with tRPC? For now, yes. But I kinda regret not going with my favorite ‚Äî GraphQL. I gave in to the hype around these modern tools and wanted to try something new ‚Äî just to once again confirm that GraphQL is the GOAT. I just thought setting up a GraphQL backend would be more complicated than tRPC ‚Äî which turned out to be true. Also, there‚Äôs still no great frontend client with a DX similar to `react-query`. Sure, there‚Äôs [`apollo-client`](https://www.apollographql.com/), but if you‚Äôve ever tried manually updating a cached object (instead of just doing `refetchQuery`), you know that `react-query` and `apollo-client` are poles apart. I personally miss good type inference on the cache operations.

### Pros of GraphQL

- Backend-agnostic
- Great type generation, typed hooks, and enums (which really makes life easier)
- Flexibility: I can fetch only the fields I need, not everything
- Resolvers: I can define a separate resolver for each field, which is super handy. Technically I do the same in tRPC when I have calculated fields. But the downside is, if I call a procedure, I fetch the calculated field even if I don‚Äôt need it. I could move it to a separate procedure, but that‚Äôs more manual work.

Regarding breaking changes ‚Äî with GraphQL, we change the schema and add @deprecated annotations. In theory, I‚Äôll do the same with tRPC (haven‚Äôt reached that point yet), and the IDE should highlight deprecated methods.

I won‚Äôt go over all pros and cons of these approaches ‚Äî that wasn‚Äôt the point of the article. I just wanted to say: don‚Äôt overthink it. There‚Äôs no perfect solution. You‚Äôre better off spending that time writing documentation, a business plan, or doing marketing instead of rewriting your backend for the hundredth time ‚Äî which you‚Äôll probably rewrite again in a few weeks. Of course, it‚Äôs good to understand different approaches, but in solo projects (even commercial ones), it‚Äôs often overkill. I believe good typing can sometimes replace good architecture (though that thought probably needs elaboration ‚Äî but if you get it, you get it). Finding balance is an art we all still need to learn.

# Summary

- **REST API** ‚Äî dead end in TS world ü•¥. I'm not saying it's obsolete, but it's not convenient for fully-typed monorepos. Yes, you have tons of tools for autogenerating types, even for setting up the entire REST API from PostgreSQL schemas and other cool stuff... But, I'd only use it if I know for sure I‚Äôll be writing the frontend in something other than TypeScript, or if I‚Äôll be writing microservices in different languages. Otherwise, I‚Äôd avoid it.

- **tRPC** ‚Äî seems fine, at least for small startups. If you don‚Äôt have a ready-made GraphQL backend setup to copy, I‚Äôd go with tRPC. Especially since GraphQL might be overkill for your tiny project that you‚Äôll abandon in a few days. And if you‚Äôre not using a monorepo, consider either migrating to one or sticking with GraphQL/REST.

- **GraphQL** ‚Äî powerful. Never had real issues with it *(aside from manually updating caches in `apollo-client` ‚Äî it works, but type safety is awful. In theory, you could try using `react-query` + `graphql-request`, and also [codegen](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-react-query). I haven‚Äôt tried it yet, so maybe I‚Äôll write a short review on that another time)*. But it‚Äôs a bit of a hassle to set up. I just wish there was a better client for it. Besides that, you‚Äôll have to write a lot of boilerplate code and deal with the complexity of setting up the backend. But once you do, it‚Äôs great.

So, if you already have a working GraphQL project ‚Äî just copy it, update the packages, and start your new business. No need to waste time configuring it all from scratch again. I regret not realizing this earlier.

**P.S.** While writing this article, I barely resisted the urge to rewrite that damn backend to GraphQL instead of tRPC one more time...

**P.S.** Don't use this article as a guide for your startup. It's just a personal opinion. I don't know what I'm doing, and I don't want to be responsible for your decisions. Just do whatever you think is best for you.

**P.S.** This "comparison" was written based on mobile app and backend development. For other web projects, the situation might be different.
