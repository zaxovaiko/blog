# REST API, tRPC, or GraphQL? What would you choose for your new startup?

Recently, I decided to bring one of my countless startup ideas to life, and I got stuck on choosing a communication protocol between the mobile app and the backend. Unusually for me, I chose the path of least resistance and decided not to overthink architecture and so on â€” just to start building the product. Knowing that it likely wonâ€™t ever see the light of day, I didnâ€™t worry much about optimizations, architecture, folder structures, or developer experience. I just wanted to start coding the product in a way that was reasonably convenient for me.

So, in short â€” this was supposed to be a mobile app with a separate backend. I donâ€™t like building serverless apps because they limit me a bit. Sometimes itâ€™s hard to implement file size/type validators, notification logic, cron jobs, etc. I prefer building a separate backend from the start so that the project is frontend-independent. That way I can change the UI anytime without having to move or rewrite a lot of business logic. _But thatâ€™s not the point of this story._

## REST API
As usual, I decided to use a REST API. I wrote some standard endpoints using the Hono framework. I couldâ€™ve used Express, but since the developer behind Express also created Hono, I figured there was some reasoning behind it. Everything was fine, the backend worked, so I moved on to the mobile app. Thatâ€™s when problems started appearing. I used `react-query` as the client to communicate with the backend. Pretty quickly, I realized I was missing generated types. â€œWriting them manually is really dumb. I donâ€™t see the point in duplicating types when I could just generate them using some toolâ€ - I thought.

### OpenAPI

Thatâ€™s why I decided to integrate my backend with OpenAPI. Luckily, Hono has integration with `zod-openapi`, which allows defining endpoints strictly using Zod schemas. I refactored the backend a bit and got to work on the mobile app. On the frontend, I used the `orval` library, which parsed the OpenAPI schema and generated types and typed hooks for `react-query`. That was better, I thought. But the types had weird names like `GetUsersResponseOpenApi200` or something like that. I get it â€” the backend can return different statuses and errors â€” but for a startup Iâ€™m building just to test an idea, that was overkill. I didnâ€™t want to handle every error or add custom statuses to Zod schemas in `hono-zod-openapi`, and then deal with a mess of types generated by `orval`. I didnâ€™t like it â€” it looked messy. I still wanted to simplify the DX so I could focus more on business logic than type definitions and schema configurations.

## tRPC

So I decided to try tRPC, which would give me powerful typing out of the box without complex configuration or auto-generating types. Itâ€™s worth noting that Iâ€™m working in a monorepo, so I can easily import the main app router type on the frontend. If youâ€™re using separate repos for frontend and backend, you could theoretically still do this â€” youâ€™d just need to locally link the backend package or set up automatic publishing. But yeah, itâ€™s a bit of extra work and arguably not easier than using OpenAPI.

### Monorepos again...

In my monorepo setup, though, development became easier. I had to refactor the backend a bit again, but now I know for sure: REST API is a thing of the past for me. Since tRPC communicates over HTTP, itâ€™s essentially a typed REST API. If you write a backend in tRPC and later want to change the frontend to another language (not TypeScript), you can still make requests to the backend â€” you just wonâ€™t have type safety. But in that case, youâ€™d probably have to define an OpenAPI spec and tweak the backend a bit anyway. I mostly use TypeScript for everything, so Iâ€™m not worried.

Additionally, since Iâ€™m working in a monorepo, it made sense to create a shared package with Zod schemas to avoid duplicating code. Very convenient â€” I recommend doing the same.

### Enums

However, one small issue remains. I havenâ€™t found a way to share enums between the frontend and backend. I use Prisma, which generates types and enums. But the problem is I canâ€™t use them on the frontend without adding Prisma as a dependency â€” which I donâ€™t actually use there. As a workaround, I just duplicated the enums into a shared package and used them on the frontend.

Another option would be to create a separate shared package that only exports the generated enums. But thatâ€™s a lot of manual, one-time work and a bit of overkill. At least in Prisma version 6.7.0, it now generates separate modules (enums, types, etc.), which might simplify this setup later. But thatâ€™s for another time (never).

## GraphQL

So, did I stick with tRPC? For now, yes. But I kinda regret not going with my favorite â€” GraphQL. I gave in to the hype around these modern tools and wanted to try something new â€” just to once again confirm that GraphQL is the GOAT. I just thought setting up a GraphQL backend would be more complicated than tRPC â€” which turned out to be true. Also, thereâ€™s still no great frontend client with a developer experience similar to react-query. Sure, thereâ€™s apollo-client, but if youâ€™ve ever tried manually updating a cached object (instead of just doing refetchQuery), you know that react-query and apollo-client are night and day. I personally miss automatically typed operations on the cache.

### But here are some pros of GraphQL:

- Backend-agnostic
- Great type generation, typed hooks, and enums (which really makes life easier)
- Flexibility: I can fetch only the fields I need, not everything
- Resolvers: I can define a separate resolver for each field, which is super handy. Technically I do the same in tRPC when I have calculated fields. But the downside is, if I call a procedure, I fetch the calculated field even if I donâ€™t need it. I could move it to a separate procedure, but thatâ€™s more manual work.

Regarding breaking changes â€” with GraphQL, we change the schema and add @deprecated annotations. In theory, Iâ€™ll do the same with tRPC (havenâ€™t reached that point yet), and the IDE should highlight deprecated methods.

I wonâ€™t go over all pros and cons of these approaches â€” that wasnâ€™t the point. I just wanted to say: donâ€™t overthink it. Thereâ€™s no perfect solution. Youâ€™re better off spending that time writing documentation, a business plan, or doing marketing instead of rewriting your backend for the hundredth time â€” which youâ€™ll probably rewrite again in a few weeks. Of course, itâ€™s good to understand different approaches, but in solo projects (even commercial ones), itâ€™s often overkill. I believe good typing can sometimes replace good architecture (though that thought probably needs elaboration â€” but if you get it, you get it). Finding balance is an art we all still need to learn.

## So, to summarize:

- REST API â€” brrr ğŸ« . I'm not saying it's obsolete, but it's not convenient for fully-typed monorepos. Yes, you have tons of tools for autogenerating types, even for setting up the entire REST API from PostgreSQL schemas and other cool stuff... But, I'd only use it if I know for sure Iâ€™ll be writing the frontend in something other than TypeScript, or if Iâ€™ll be writing microservices in different languages. Otherwise, Iâ€™d avoid it.
- tRPC â€” seems fine, at least for small startups. If you donâ€™t have a ready-made GraphQL backend setup to copy, Iâ€™d go with tRPC. Especially since GraphQL might be overkill for your tiny project that youâ€™ll abandon in a few days. And if youâ€™re not using a monorepo, consider either migrating to one or sticking with GraphQL/REST.
- GraphQL â€” powerful. Never had real issues with it (aside from manually updating caches in `apollo-client` â€” it works, but type safety is awful). In theory, you could try using `react-query` + `graphql-request`, and also [codegen](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-react-query). I havenâ€™t tried it yet, so maybe Iâ€™ll write a short review on that another time.

So, if you already have a working GraphQL project â€” just copy it, update the package versions, and start your new business. No need to waste time configuring it all from scratch again. I regret not realizing this earlier.

**P.S.** While writing this article, I barely resisted the urge to rewrite that damn backend to GraphQL instead of tRPC one more time...

